module Main where

import Control.Monad
import Data.Array.MArray
import Data.Array.ST
import qualified Data.Map.Strict as Map

type CKYTable = Map.Map (Integer, Integer) [(LexicalEntry, String)]

-- | CYK parsing, but we just keep the full derivations. The input string
-- s should be a string that can be parsed with this grammar.
generate :: String -> CKYTable
generate utterance = ckyTable
  where
    tokens = words utterance
    n = length tokens
    enumeratedTokens = zip [1..] tokens

    -- In imperative versions, this is usually something like:
    --   for each token w_i
    --      set table entry (i-1, i) to lexicon(w_i)
    initialCKYEntry (idx, token) = ((idx - 1, idx), (filterLexicon token))
    ckyTable = Map.fromList (map initialCKYEntry enumeratedTokens)

--    arr = runSTUArray $ do
--      marr <- newArray ((0, 0), (n, n)) False
--      forM_ (zip [1..] tokens) $ \(idx, token) ->
--        writeArray marr (idx - 1, idx) True
--      return marr
--
--      forM_ [2..n] $ \j ->
--        forM_ (reverse [0..(j-1)]) $ \i ->
--          forM_ [(i+1)..(j)] $ \k -> do
--            c0 <- readArray marr (i, k)
--            c1 <- readArray marr (k, j)
--            case (c0, c1) of
--              (True, True) -> writeArray marr (i, j) True
--              _ -> writeArray marr (i, j) False
--      return marr

-- | Interpret, as Haskell code, the root of a logical form generated by
-- this grammar. Also known as @Grammar#sem@.
interpret :: String -> String
interpret lf = "I am a logical form!"

-- A lexical entry is a tuple of (category, logical form).
type LexicalEntry = (Char, String)

-- Helper method to retrieve the lexical entries for a given token
-- TODO: Not quite the same as example: [[(LexicalEntry, String)]]
filterLexicon :: String -> [(LexicalEntry, String)]
filterLexicon token = map (\v -> (v, token)) filteredEntries
    where filteredLexicon = Map.filterWithKey (\k _ -> k == token) lexicon
          filteredEntries = concat (Map.elems filteredLexicon)

-- A lexicon is a mapping from strings to arrays of lexical entries.
lexicon :: Map.Map String [LexicalEntry]
lexicon = Map.fromList [
                         ("one",   [('N', "1")])
                       , ("two",   [('N', "2")])
                       , ("three", [('N', "3")])
                       , ("four",  [('N', "4")])
                       , ("plus",  [('R', "add")])
                       , ("minus", [('R', "subtract"), ('U', "neg")])
                       , ("times", [('R', "multiply")])
                       ]

data LexicalRule = LexicalRule {
                 leftChild    :: Char
                 , rightChild :: Char
                 , parent     :: Char
                 , forward    :: Bool
                 }

-- Binarized version of the rule sets from the paper. These correspond to:
--  N -> B N  semantics: apply B(N)
--  N -> U N  semantics: apply U(N)
--  B -> N R  semantics: apply R(N)
rules :: [LexicalRule]
rules = [
          (LexicalRule 'B' 'N' 'N' True)
        , (LexicalRule 'U' 'N' 'N' True)
        , (LexicalRule 'N' 'R' 'B' False)
        ]

functions :: Map.Map String (Integer -> Integer -> Integer)
functions = Map.fromList [
                           ("plus",  (+))
                         , ("minus", (-))
                         , ("times", (*))
                         ]

main :: IO ()
main = do
    putStrLn $ show lexicon
    putStrLn $ show (Map.lookup "one" lexicon)
    putStrLn $ show $ (functions Map.! "plus" ) 1 4
    putStrLn $ show $ generate "one plus one"
